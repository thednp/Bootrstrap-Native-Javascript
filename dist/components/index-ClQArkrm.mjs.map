{"version":3,"file":"index-ClQArkrm.mjs","sources":["../../node_modules/.pnpm/@thednp+position-observer@1.0.4/node_modules/@thednp/position-observer/dist/index.mjs"],"sourcesContent":["const m = (e) => e != null && typeof e == \"object\" || !1, p = (e) => m(e) && typeof e.nodeType == \"number\" && [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11].some(\n  (t) => e.nodeType === t\n) || !1, h = (e) => p(e) && e.nodeType === 1 || !1, w = (e) => typeof e == \"function\" || !1, k = \"1.0.4\", a = \"PositionObserver Error\";\nclass v {\n  entries;\n  static version = k;\n  _tick;\n  _root;\n  _callback;\n  /**\n   * The constructor takes two arguments, a `callback`, which is called\n   * whenever the position of an observed element changes and an `options` object.\n   * The callback function should take an array of `PositionObserverEntry` objects\n   * as its only argument, but it's not required.\n   *\n   * @param callback the callback that applies to all targets of this observer\n   * @param options the options of this observer\n   */\n  constructor(t, i) {\n    if (!w(t))\n      throw new Error(`${a}: ${t} is not a function.`);\n    this.entries = /* @__PURE__ */ new Map(), this._callback = t, this._root = h(i?.root) ? i.root : document?.documentElement, this._tick = 0;\n  }\n  /**\n   * Start observing the position of the specified element.\n   * If the element is not currently attached to the DOM,\n   * it will NOT be added to the entries.\n   *\n   * @param target an `Element` target\n   */\n  observe = (t) => {\n    if (!h(t))\n      throw new Error(\n        `${a}: ${t} is not an instance of Element.`\n      );\n    this._root.contains(t) && this._new(t).then((i) => {\n      i && !this.getEntry(t) && this.entries.set(t, i), this._tick || (this._tick = requestAnimationFrame(this._runCallback));\n    });\n  };\n  /**\n   * Stop observing the position of the specified element.\n   *\n   * @param target an `HTMLElement` target\n   */\n  unobserve = (t) => {\n    this.entries.has(t) && this.entries.delete(t);\n  };\n  /**\n   * Private method responsible for all the heavy duty,\n   * the observer's runtime.\n   */\n  _runCallback = () => {\n    if (!this.entries.size) return;\n    const t = new Promise((i) => {\n      const r = [];\n      this.entries.forEach(\n        ({ target: s, boundingClientRect: n }) => {\n          this._root.contains(s) && this._new(s).then(({ boundingClientRect: o, isIntersecting: u }) => {\n            if (!u) return;\n            const { left: f, top: _, bottom: l, right: b } = o;\n            if (n.top !== _ || n.left !== f || n.right !== b || n.bottom !== l) {\n              const c = { target: s, boundingClientRect: o };\n              this.entries.set(s, c), r.push(c);\n            }\n          });\n        }\n      ), i(r);\n    });\n    this._tick = requestAnimationFrame(async () => {\n      const i = await t;\n      i.length && this._callback(i, this), this._runCallback();\n    });\n  };\n  /**\n   * Calculate the target bounding box and determine\n   * the value of `isVisible`.\n   *\n   * @param target an `Element` target\n   */\n  _new = (t) => new Promise((i) => {\n    new IntersectionObserver(\n      ([s], n) => {\n        n.disconnect(), i(s);\n      }\n    ).observe(t);\n  });\n  /**\n   * Find the entry for a given target.\n   *\n   * @param target an `HTMLElement` target\n   */\n  getEntry = (t) => this.entries.get(t);\n  /**\n   * Immediately stop observing all elements.\n   */\n  disconnect = () => {\n    cancelAnimationFrame(this._tick), this.entries.clear(), this._tick = 0;\n  };\n}\nexport {\n  v as default\n};\n//# sourceMappingURL=index.mjs.map\n"],"names":["m","p","k","v","i","r","s","n","o","u","f","_","l","b"],"mappings":"AAAA,MAAMA,IAAI,CAAC,MAAM,KAAK,QAAQ,OAAO,KAAK,YAAY,IAAIC,IAAI,CAAC,MAAMD,EAAE,CAAC,KAAK,OAAO,EAAE,YAAY,YAAY,CAAC,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,EAAE,EAAE;AAAA,EAChJ,CAAC,MAAM,EAAE,aAAa;AACxB,KAAK,IAAI,IAAI,CAAC,MAAMC,EAAE,CAAC,KAAK,EAAE,aAAa,KAAK,IAAI,IAAI,CAAC,MAAM,OAAO,KAAK,cAAc,IAAIC,IAAI,SAAS,IAAI;AAC9G,MAAMC,EAAE;AAAA,EACN;AAAA,EACA,OAAO,UAAUD;AAAA,EACjB;AAAA,EACA;AAAA,EACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,YAAY,GAAGE,GAAG;AAChB,QAAI,CAAC,EAAE,CAAC;AACN,YAAM,IAAI,MAAM,GAAG,CAAC,KAAK,CAAC,qBAAqB;AACjD,SAAK,UAA0B,oBAAI,IAAK,GAAE,KAAK,YAAY,GAAG,KAAK,QAAQ,EAAEA,GAAG,IAAI,IAAIA,EAAE,OAAO,UAAU,iBAAiB,KAAK,QAAQ;AAAA,EAC7I;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQE,UAAU,CAAC,MAAM;AACf,QAAI,CAAC,EAAE,CAAC;AACN,YAAM,IAAI;AAAA,QACR,GAAG,CAAC,KAAK,CAAC;AAAA,MACX;AACH,SAAK,MAAM,SAAS,CAAC,KAAK,KAAK,KAAK,CAAC,EAAE,KAAK,CAACA,MAAM;AACjD,MAAAA,KAAK,CAAC,KAAK,SAAS,CAAC,KAAK,KAAK,QAAQ,IAAI,GAAGA,CAAC,GAAG,KAAK,UAAU,KAAK,QAAQ,sBAAsB,KAAK,YAAY;AAAA,IAC3H,CAAK;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMD,YAAY,CAAC,MAAM;AACjB,SAAK,QAAQ,IAAI,CAAC,KAAK,KAAK,QAAQ,OAAO,CAAC;AAAA,EAC7C;AAAA;AAAA;AAAA;AAAA;AAAA,EAKD,eAAe,MAAM;AACnB,QAAI,CAAC,KAAK,QAAQ,KAAM;AACxB,UAAM,IAAI,IAAI,QAAQ,CAACA,MAAM;AAC3B,YAAMC,IAAI,CAAE;AACZ,WAAK,QAAQ;AAAA,QACX,CAAC,EAAE,QAAQC,GAAG,oBAAoBC,EAAC,MAAO;AACxC,eAAK,MAAM,SAASD,CAAC,KAAK,KAAK,KAAKA,CAAC,EAAE,KAAK,CAAC,EAAE,oBAAoBE,GAAG,gBAAgBC,EAAC,MAAO;AAC5F,gBAAI,CAACA,EAAG;AACR,kBAAM,EAAE,MAAMC,GAAG,KAAKC,GAAG,QAAQC,GAAG,OAAOC,EAAC,IAAKL;AACjD,gBAAID,EAAE,QAAQI,KAAKJ,EAAE,SAASG,KAAKH,EAAE,UAAUM,KAAKN,EAAE,WAAWK,GAAG;AAClE,oBAAM,IAAI,EAAE,QAAQN,GAAG,oBAAoBE,EAAG;AAC9C,mBAAK,QAAQ,IAAIF,GAAG,CAAC,GAAGD,EAAE,KAAK,CAAC;AAAA,YAC9C;AAAA,UACA,CAAW;AAAA,QACX;AAAA,MACA,GAASD,EAAEC,CAAC;AAAA,IACZ,CAAK;AACD,SAAK,QAAQ,sBAAsB,YAAY;AAC7C,YAAMD,IAAI,MAAM;AAChB,MAAAA,EAAE,UAAU,KAAK,UAAUA,GAAG,IAAI,GAAG,KAAK,aAAc;AAAA,IAC9D,CAAK;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOD,OAAO,CAAC,MAAM,IAAI,QAAQ,CAACA,MAAM;AAC/B,QAAI;AAAA,MACF,CAAC,CAAC,CAAC,GAAGG,MAAM;AACV,QAAAA,EAAE,WAAU,GAAIH,EAAE,CAAC;AAAA,MAC3B;AAAA,IACA,EAAM,QAAQ,CAAC;AAAA,EACf,CAAG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMD,WAAW,CAAC,MAAM,KAAK,QAAQ,IAAI,CAAC;AAAA;AAAA;AAAA;AAAA,EAIpC,aAAa,MAAM;AACjB,yBAAqB,KAAK,KAAK,GAAG,KAAK,QAAQ,MAAO,GAAE,KAAK,QAAQ;AAAA,EACtE;AACH;","x_google_ignoreList":[0]}